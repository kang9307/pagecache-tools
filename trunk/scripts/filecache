#!/usr/bin/ruby -w

$BDEV_ID = 0xFFFF0002
$BDEV_NAME = 'bdev'

#
# Class representing a fstab/mtab entry extended with device_id.
#
class FileSystem

  def initialize (device_file, mount_point, fstype)
    @device_file = device_file
    @mount_point = mount_point
    @fstype      = fstype

    @device_id =
      if   @device_file == $BDEV_NAME then    $BDEV_ID
      elsif File.exist?(@device_file) then  File.stat(@device_file).rdev
      else @device_file.tr! '/', '-';       File.stat(@mount_point).dev end
  end

  def to_s
    "FileSystem:\t#{major}:#{minor}\t#{device_file}\t#{mount_point}\t#{fstype}"
  end

  def major() @device_id >> 8   end
  def minor() @device_id & 0xff end

  attr_reader :device_id, :device_file, :mount_point, :fstype

end

#
# Class representing a collection of fstab/mtab entries extended with device_id
#
class FSTab

  # retrieve fs entries from /etc/fstab or /etc/mtab or /proc/mounts
  def initialize (file = '/etc/fstab')

    @fs_by_id = Hash.new

    File.foreach(file) do |line|

      dev, mp, fstype, options = line.split

      next if mp[0] != ?/       # skip pseudo fs
      next if fstype =~ /(tmpfs|ramfs)/
      next if fstype =~ /(sysfs|rootfs|proc|debugfs|securityfs|sockfs)/
      next if fstype =~ /(pipefs|futexfs|inotifyfs|eventpollfs|devpts)/
      next if fstype =~ /(mqueue|usbfs|binfmt_misc)/
      next if options =~ /loop/ # no need to readahead loop fs

      fs = FileSystem.new(dev, mp, fstype)
      @fs_by_id[fs.device_id] ||= fs

    end  # File.foreach

    @fs_by_id.delete(0) # in case we get device_id=0 for hotplug devices.

    # the filesystem for block special files
    @fs_by_id[$BDEV_ID] = FileSystem.new($BDEV_NAME, "", $BDEV_NAME)

    self
  end

  def each
    @fs_by_id.each_value { |fs| yield(fs) }
    self
  end

  def [] (device_id)
    @fs_by_id[device_id]
  end

  def to_s
    ret = "FSTab:\n"

    @fs_by_id.each_value do |fs|
      ret = ret + "#{fs.to_s}\n"
    end

    ret
  end

end


#
# Class representing one cached file
#
class CachedFile

  def CachedFile.reset_seq
    @@seq = 0
  end

  def CachedFile.filecache
    unless defined? @@filecache
      @@filecache = File.open('/proc/filecache', File::RDWR)
      @@filecache.syswrite 'private session'
      @@filecache.rewind
    end
    @@filecache
  end

  attr_reader   :dev, :file, :pages, :seq
  attr_accessor :ino, :size, :state, :refcnt

  def initialize(file)
    @file = file
    @seq  = @@seq
    @@seq = @@seq + 1
    @pages = Hash.new
  end

  def init_pages
    filecache = CachedFile.filecache
    filecache.rewind
    filecache.syswrite @file
    filecache.rewind
    filecache.each_line do |line|
      idx, len, state, refcnt = line.split
      idx, len, refcnt = idx.to_i, len.to_i, refcnt.to_i
      next unless yield(idx, len, state, refcnt)
      add_page_range idx, len
    end
  end

  def add_page_range(idx, len = 1)
    len.times { |i| @pages[idx + i] = len }
  end

  def init_attrs(line = nil)
    if line
      ino, size, cached, cachedp, state,
        refcnt, dev, file = line.split
      @state  = state
      @refcnt = refcnt.to_i
    end

    stat = File.lstat(@file)
    if stat.blockdev?
      @dev = $BDEV_ID
    else
      @dev = stat.dev
    end

    @ino  = stat.ino
    @size = (stat.size + 1023) / 1024
  end

  def cached
    4 * @pages.size    # TODO: respect PAGE_SIZE
  end

  def cached_percent
    if @size > 0
      percent = (self.cached / @size.to_f).to_i
      percent = 100 if percent > 100
    else
      percent = 0
    end
    percent
  end

  def blockdev?
    @dev == $BDEV_ID
  end

  def empty?
    @pages.empty?
  end

  def union(cfile)
    @pages.update cfile.pages
    self
  end

  def intersection(cfile)
    @pages.delete_if { |k, v| not cfile.pages.include?(k) }
    self
  end

  def difference(cfile)
    @pages.delete_if { |k, v| cfile.pages.include?(k) }
    self
  end

  def page_ranges
    list = []
    idx = 0;
    len = 0;

    @pages.keys.sort.each do |offset|
      if idx + len == offset
        len = len + 1
      else
        if len > 0
          list << [idx, len]
        end
        idx = offset
        len = 1
      end
    end

    if len > 0
      list << [idx, len]
    end

    list
  end

  def to_s
    list = page_ranges

    s = "#{@file}\n"
    list.each do |page|
      s = s + "#{page[0]}\t#{page[1]}\n"
    end
    s = s + "\n"

  end

end

#
# Class representing an ordered list of cached files
#
class CachedFileList

  @@fstab = FSTab.new '/etc/mtab'

  def initialize
    @cfile_by_name = Hash.new
    self
  end

  def union(cfl)
    cfl.each do |cfile|
      cf = @cfile_by_name[cfile.file]
      if cf
        cf.union cfile
      else
        @cfile_by_name[cfile.file] = cfile
      end
    end
    self
  end

  def intersection(cfl)
    @cfile_by_name.each_value do |cfile|
      cf = cfl[cfile.file]
      if cf
        cfile.intersection cf
      else
        @cfile_by_name.delete cfile.file
      end
    end
    self
  end

  def difference(cfl)
    @cfile_by_name.each_value do |cfile|
      cf = cfl[cfile.file]
      if cf != nil
        cfile.difference cf
      end
    end
    self
  end

  def each
    @cfile_by_name.values.sort {|x,y| x.seq <=> y.seq} .each do |cfile|
        yield cfile
    end
    self
  end

  def [](file)
    @cfile_by_name[file]
  end

  def delete(file)
    @cfile_by_name.delete file
    self
  end

  def delete_if
    @cfile_by_name.delete_if do |key, cfile|
      yield(cfile)
    end
    self
  end

  # Take a snapshot of /proc/filecache.
  def snapshot(condition = 'true')
    filecache = CachedFile.filecache

    read_filecache_index filecache

    @cfile_by_name.each_value do |cfile|
      cfile.init_pages do |idx, len, state, refcnt|
        eval condition
      end
    end

    self
  end

  # get the cached file list from /proc/filecache.
  def read_filecache_index(filecache)
    CachedFile.reset_seq
    filecache.rewind
    filecache.syswrite('index')
    filecache.rewind
    filecache.each_line do |line|
      next if line[0] == ?#

      dev, file = line.split.values_at(-2, -1)
      next if file == '(noname)'
      if file.include? ?\\
        file.gsub! '\011', "\011"  # ht
        file.gsub! '\012', "\012"  # nl
        file.gsub! '\040', "\040"  # sp
        file.gsub! '\\',   "\\"    # \
      end

      if file =~ /\([0-9a-f]{2}:[0-9a-f]{2}\)/ then
        # handle block device
        # - transform file name from digital form to real ones
        dev = file.delete('(:)').hex
        fs  = @@fstab[dev]
        unless fs
          puts "unknown device file #{file}" if $verbose >= 2
          next
        end
        file  = fs.device_file
      else
        # handle normal files
        # - expand file name to full path name
        # - ignore dirs/symlinks
        dev = dev[0,5].delete(':').hex
        fs = @@fstab[dev]
        next unless fs
        file = fs.mount_point + file unless fs.mount_point == '/'
        next unless File.file?(file)
      end

      cfile = CachedFile.new file
      cfile.init_attrs line
      @cfile_by_name[file] = cfile
    end # filecache.each_line
  end

  # Load the pre-saved snapshot of /proc/filecache from a file or dir
  def load(path)
    if File.file? path
      load_file path
    elsif File.directory? path
      Dir.foreach(path) do |file|
        file = "#{path}/#{file}"
        next unless File.stat(file).file?
        load_file file
      end
    else
      $stderr.puts "#{@path} not a file or directory."
      exit 1
    end
    self
  end

  # Load cached files' info from a pre-saved file.
  def load_file(file)

    CachedFile.reset_seq

    cfile = nil
    File.foreach(file) do |line|
      next if line.empty?
      next if line[0] == ?#

      line.chomp!
      if line[0] == ?/
        cfile = CachedFile.new line
        next unless File.exist?(line) # sorry for creating cfile just to abandon it :(
        cfile.init_attrs
        @cfile_by_name[cfile.file] = cfile if @@fstab[cfile.dev]
      elsif line =~ /^\d+\s+\d+/
        idx, len = line.split
        cfile.add_page_range idx.to_i, len.to_i
      end

    end # File.foreach
    self
  end

  def dump(dir)
    fds = Hash.new

    @cfile_by_name.delete_if { |key, cfile| cfile.empty? }
    @cfile_by_name.values.sort { |x,y| x.seq <=> y.seq} .each do |cfile|
      fs = @@fstab[cfile.dev]
      next unless fs
      fds[cfile.dev] ||= File.open("#{dir}/#{File.basename fs.device_file}",
                                    File::CREAT | File::TRUNC | File::RDWR)
      fds[cfile.dev].printf("%s", cfile.to_s)
    end

    fds.each_value { |fd| fd.close }
    self
  end

end

#
# filecache - a cmdline tool for /proc/filecache related operations
#

require 'optparse'
require 'ostruct'
require 'fileutils'

$verbose = 0

$cfiles = CachedFileList.new

opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.separator ""
  opts.separator "Available options:"


  opts.on("-v", "--verbose [LEVEL]", "set level of verbosity") do |level|
    $verbose = (level || 1).to_i
  end

  opts.on("-s", "--snapshot [CONDITION]", "take snapshot of /proc/filecache with pages satisfy the CONDITION.") do |condition|
    $cfiles.snapshot(condition || 'true')
  end

  opts.on("-l", "--load SRC", "load the pre-saved snapshot from SRC file/dir.") do |src|
    $cfiles.load src
  end

  opts.on("-d", "--dump DST", "dump the snapshot to the DST dir.") do |dst|
    Dir.mkdir(dst) if !FileTest.exist?(dst)
    $cfiles.dump dst
  end

  opts.on("-u", "--union SRC", "the set union.") do |src|
    $cfiles.union CachedFileList.new.load(src)
  end

  opts.on("-i", "--intersection SRC", "the set intersect between pre-snapshort and SRC.") do |src|
    $cfiles.intersection CachedFileList.new.load(src)
  end

  opts.on("-f", "--difference SRC", "the set difference between pre-snapshort and SRC.") do |src|
    $cfiles.difference CachedFileList.new.load(src)
  end

  opts.on("-F", "--rdifference SRC", "the set difference between pre-snapshort and SRC.") do |src|
    c = CachedFileList.new.load(src)
    c.difference $cfiles
    $cfiles = c
  end

  opts.on("--prune-path PATTERN", "exclude files matching PATTERN.") do |pattern|
    p = Regexp.new(pattern)
    $cfiles.delete_if { |f| p =~ f.file }
  end

  opts.on("--delete-if CONDITION", "delete files satisfying CONDITION.") do |condition|
    $cfiles.delete_if { |f| eval condition }
  end

  opts.on("--defrag HABITAT", "do poor man's defrag via dir HABITAT.") do |habitat|

    unless 'Ss016'.include? `runlevel`[2]
      print 'WARNING: defraging in multi-user mode may lead to data corruption. Continue anyway? [y/N]'
      if $stdin.readline[0] != ?y then exit end
    end

    mtab = FSTab.new '/etc/mtab'
    $cfiles.each do |f|
      # skip obscure files
      fstat = File.lstat f.file
      next unless fstat.file?

      # skip opened files
      File.open(f.file) do |fd|
        unless fd.flock(File::LOCK_EX | File::LOCK_NB)
          puts "skiping opened file #{f.file}" if $verbose >= 2
          next
        end
        fd.flock(File::LOCK_UN)
      end

      # check habitat dir existence
      hdir  = mtab[f.dev].mount_point + '/' + habitat
      hfile = hdir + '/' + File.basename(f.file)
      unless File.directory? hdir
        $stderr.puts "defrag habitat directory #{hdir} do not exist"
        exit 1
      end

      # poor man's defrag ;-)
      begin
        FileUtils.cp f.file, hfile, :preserve => true
        tstat = File.lstat hfile
        raise "not in same filesystem" if fstat.dev != tstat.dev
        raise "file changed" if fstat.size != tstat.size or
                                fstat.mode != tstat.mode or
                                fstat.mtime != tstat.mtime
        FileUtils.rm f.file
        FileUtils.ln hfile, f.file
        FileUtils.rm hfile
      rescue Exception => msg
        $stderr.puts "Failed to defrag file #{f.file} => #{hfile}: #{msg}."
        exit 1
      end
    end
  end

  opts.on_tail("-h", "--help", "Show this message.") do
    puts opts
  end
end

opts.parse(ARGV)

# vim: sw=2 ts=2 et
