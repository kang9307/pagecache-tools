#!/usr/bin/ruby -w

#
# Class representing a fstab/mtab entry extended with device_id.
#
class FileSystem

  def FileSystem.get_device_id(device_file)

    while FileTest.symlink?(device_file)
      device_file = File.readlink(device_file)
    end

    if FileTest.exist?(device_file)

      fstat = File.stat(device_file)

      if fstat.blockdev? then
        return fstat.rdev
      end

    end

		return 0
  end

  def initialize (device_file, mount_point, fstype)

    @device_file = device_file 
    @mount_point = mount_point
    @fstype      = fstype
    @device_id   = FileSystem.get_device_id @device_file

  end


  def to_s
    "FileSystem:\t#{major}:#{minor}\t#{device_file}\t#{mount_point}\t#{fstype}"
  end

  def major()	@device_id >> 8   end
  def minor()	@device_id & 0xff	end

  attr_reader :device_id, :device_file, :mount_point, :fstype 

end

#
# Class representing a collection of fstab/mtab entries extended with device_id
#
class FSTab

  # retrieve fs entries from /etc/fstab or /etc/mtab or /proc/mounts
  def initialize (file = '/etc/fstab')

    @fstab = Hash.new

    File.open(file, 'r') do |file|
      file.each_line do |line|

				dev, mp, type, options = line.split 

				next if not dev =~ /^\s*\/dev\//
				next if mp == 'none'
				next if type == 'swap'
				next if options =~ /loop/

				fs = FileSystem.new(dev, mp, type)
				@fstab[fs.device_id] = fs

      end # file.each_line
    end  # File.open

    @fstab[0] = nil # in case we get device_id=0 for hotplug devices.
 
  end
  
  def each
    @fstab.each_value { |fs| yield(fs) }
    self
  end

  def [] (device_id)
    @fstab[device_id]
  end

  def to_s
    ret = "FSTab:\n"

    @fstab.each_value do |fs|
      ret = ret + "#{fs.to_s}\n"
    end

    ret 
  end

end


#
# Class representing one cached file
#
class CachedFile

  attr_reader		:dev, :file, :pages, :seq
  attr_accessor	:ino, :size, :cached, :percent, :state, :refcnt

  def initialize(file, dev, seq) 
    @file       = file
    @dev        = dev
    @seq        = seq
    @pages      = Array.new
  end

  def add(idx, len = 1)
    for i in 0...len
      @pages << idx+i
    end
    self
  end

  def complete
    if not empty?
      stat     = File.lstat(@file)
      @ino     = stat.ino 
      @size    = (stat.size + 1023) / 1024
      @cached  = 4 * @pages.size    # Fix me: pagesize=4k ?
      if @size > 0
        @percent = (@cached.to_f / @size).to_i
				@percent = 100 if @percent > 100
      else
        @percent = 0
      end
      @state   = "--"
      @refcnt  = 0
    end
  end

  def blockdev?
    @seq == 0
  end

  def empty?
		false if self.blockdev?
		true if @pages.empty?
		not FileTest.exist?(@file)
  end

  def union(cfile)
    @pages.concat cfile.pages
    @pages.uniq!
    self
  end
  alias + union

  def intersection(cfile)
    @pages.delete_if do |page|
      !cfile.pages.include?(page)
    end
    self
  end
  alias & intersection

  def difference(cfile)
    @pages.delete_if do |page|
      cfile.pages.include?(page)
    end
    self
  end
  alias - difference

  def page_ranges 
    list = []
    idx = 0;
    len = 0;

    pages.sort!
    pages.each do |page|
      if idx + len == page
        len = len + 1
      else
        if len > 0
          list << [idx, len]
        end
        idx = page
        len = 1
      end
    end

    if len > 0
      list << [idx, len]
    end

    list
  end

  def to_s
    list = page_ranges

    s = "#{file}\n"
    list.each do |page|
      s = s + "#{page[0]}\t#{page[1]}\n"
    end
    s = s + "\n"

  end

end

#
# Class representing an ordered list of cached files
#
class CachedFileList

  @@fstab = FSTab.new '/etc/mtab'

  def initialize
    @cfiles = Hash.new
  end

  def union(cfl)
    cfl.each do |cfile|
      cf = @cfiles[cfile.file]
      if cf == nil
        @cfiles[cfile.file] = cfile
      else
        cf.union cfile
      end
    end
    self
  end
  alias + union

  def intersection(cfl)
    @cfiles.each_value do |cfile|
      cf = cfl[cfile.file]
      if cf == nil
        @cfiles.delete cfile.file
      else
        cfile.intersection cf
      end
    end
    @cfiles.delete_if do |key, cfile| cfile.empty? end
    self
  end
  alias & intersection

  def difference(cfl)
    @cfiles.each_value do |cfile|
      cf = cfl[cfile.file]
      if cf != nil
        cfile.difference cf 
      end
    end
    @cfiles.delete_if do |key, cfile| cfile.empty? end
    self
  end
  alias - difference

  def each
    @cfiles.values.sort {|x,y| x.seq <=> y.seq} .each do |cfile|
        yield cfile
    end
    self
  end

  def [](file)
    @cfiles[file]
  end

  def delete(file)
    @cfiles.delete file
    self
  end

  def delete_if
    @cfiles.delete_if do |key, cfile|
      yield(cfile)
    end
    self
  end

  def CachedFileList.restore(input)
    cfl = CachedFileList.new
    if input == nil or input.empty?
      cfl.snapshot do |idx,len,|
        len > 0
      end
    else
      if File.stat(input).file?
        cfl.restore_from_file input 
      else
        cfl.restore_from_dir input 
      end
    end
    cfl
  end

  # Take a snapshot of /proc/filecache.
  def snapshot 

    File.open('/proc/filecache', File::RDWR) do |filecache| 

      filecache.syswrite("private session")
      # filecache.syswrite("PRIVATE")
      read_filecache_index filecache

      @cfiles.each_value do |cfile|

        begin
          filecache.rewind
          filecache.syswrite(cfile.file)
          filecache.each_line do |line|
            idx, len, state, refcnt = line.split
            idx, len, refcnt = idx.to_i, len.to_i, refcnt.to_i
            if yield(idx, len, state, refcnt) then
              cfile.add idx, len
            end
          end
        rescue => err
          # $stderr.puts "#{err.backtrace.join("\n")}:", "\t#{err} - #{cfile.file}\n\n"
          $stderr.puts "#{err} - #{cfile.file}\n\n"
        end

      end

    end # File.open

    @cfiles.delete_if do |key, cfile| cfile.empty? end

    self
  end

  # get the cached file list from /proc/filecache.
  def read_filecache_index(filecache)
    seq = 1;
    begin
      filecache.rewind
      filecache.syswrite("index")
      filecache.each_line do |line|

        next if line[0] == ?# 

        line.gsub! '\011', "\011"  # ht
        line.gsub! '\012', "\012"  # nl
        line.gsub! '\040', "\040"  # sp
        line.gsub! '\\',   "\\"    # \

        ino, size, cached, cachedp, state, 
          refcnt, dev, file = line.split

        next if file == '(noname)'
        next if file =~ /\(deleted\)$/

        dev = "0x#{dev[0,5].delete(':')}".hex 

        if file =~ /\([0-9a-f]{2}:[0-9a-f]{2}\)/ then
          dev  = file.delete('(:)').hex
          fs   = @@fstab[dev]
          next if fs == nil
          file = fs.device_file
          cfile = CachedFile.new file, dev, 0 
        else
          fs = @@fstab[dev]
          next if fs == nil
          if fs.mount_point != "/" then
            file = fs.mount_point + file 
          end
          cfile = CachedFile.new file, dev, seq 
          seq = seq + 1;
        end


        cfile.ino     = ino.to_i
        cfile.size    = size.to_i
        cfile.cached  = cached.to_i 
        cfile.percent = cachedp.to_i
        cfile.state   = state
        cfile.refcnt  = refcnt.to_i

        @cfiles[file] = cfile 

      end
    rescue => err
      $stderr.puts "#{err.backtrace.join("\n")}:", "#{err}\n\n"
    end
  end

  # Restore the pre-saved snapshot of /proc/filecache from the files under 'dir'.
  def restore_from_dir(dir)
    begin
      Dir.foreach(dir) do |file|
        file = "#{dir}/#{file}"
        next if not File.lstat(file).file?
        seq = loadfile file
      end
    rescue => err
      $stderr.puts "#{err.backtrace.join("\n")}:", "#{err}\n\n"
    end
    @cfiles.delete_if do |key, cfile| cfile.empty? end
  end

  # Restore one partion's pre-saved snapshort of /proc/filecache from a file.
  def restore_from_file(file)
    begin
      loadfile file
    rescue => err
      $stderr.puts "#{err.backtrace.join("\n")}:", "#{err}\n\n"
    end
    @cfiles.delete_if do |key, cfile| cfile.empty? end
  end

  # Load the CachedFile info from a pre-saved files.
  def loadfile(file)

    seq = 0

    File.open(file, File::RDONLY) do |file|

      cfile = nil
      fs    = nil
      file.each_line do |line|

        next if line.empty?
        next if line[0] == ?#

        line.chomp!

        if line[0] == ?/
          if fs == nil
            fs = @@fstab[FileSystem.get_device_id(line)]
          end
          if cfile != nil
            cfile.complete
            @cfiles[cfile.file] = cfile
          end
          cfile = CachedFile.new line, fs.device_id, seq
          seq = seq + 1
        else
          idx, len = line.split
          cfile.add idx.to_i, len.to_i 
        end

      end

    end # File.open

  end

  def dump(dir)

    fds = Hash.new

    begin

			FMODE = File::CREAT | File::TRUNC | File::RDWR
			bdev_fd = File.new("#{dir}/bdev", FMODE)

			@cfiles.values.sort {|x,y| x.seq <=> y.seq} .each do |cfile|

				fs = @@fstab[cfile.dev]

        next if fs == nil

				if cfile.blockdev?
					fd = bdev_fd
				else
					fds[cfile.dev] || = File.open("#{dir}/#{File.basename fs.device_file}", FMODE) 
					fd = fds[cfile.dev]
        end

        fd.printf("%s", cfile.to_s) 
      end

			bdev_fd.close
      fds.each_value do |fd|
        fd.close
      end

    rescue => err
      $stderr.puts "#{err.backtrace.join("\n")}:", "#{err}\n\n"
    end

    self
  end

  private :loadfile

end

#
# filecache - a cmdline tool for /proc/filecache related operations
#

require 'optparse'
require 'ostruct'
require 'fileutils'

$verbose = 0

opts = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.separator ""
  opts.separator "Available options:"


  opts.on("-v", "--verbose [LEVEL]", "set level of verbosity") do |level|
    $verbose = level || 1
  end

  opts.on("-s", "--snapshot [CONDITION]", "take snapshot of /proc/filecache with pages satisfy the CONDITION.") do |condition|
    $cfiles = CachedFileList.new
    $cfiles.snapshot do |idx, len, state, refcnt|
      if condition == nil or condition.empty?
        true
      else
        eval condition 
      end
    end
  end

  opts.on("-r", "--restore SRC", "restore the pre-saved snapshot from SRC file/dir.") do |src|
    $cfiles = CachedFileList.restore src
  end

  opts.on("-d", "--dump DST", "dump the snapshot to the DST dir.") do |dst|
    Dir.mkdir(dst) if !FileTest.exist?(dst)
    $cfiles.dump dst
  end

  opts.on("-u", "--union SRC", "the set union.") do |src|
    $cfiles.union CachedFileList.restore(src) 
  end

  opts.on("-i", "--intersection SRC", "the set intersect between pre-snapshort and SRC.") do |src|
    $cfiles.intersection CachedFileList.restore(src) 
  end

  opts.on("-f", "--difference SRC", "the set difference between pre-snapshort and SRC.") do |src|
    $cfiles.difference CachedFileList.restore(src) 
  end

  opts.on("-F", "--rdifference SRC", "the set difference between pre-snapshort and SRC.") do |src|
    $cfiles = CachedFileList.restore(src).difference $cfiles
  end

  opts.on("--prune-path PATTERN", "exclude files matching PATTERN.") do |pattern| 
		p = Regexp.new(pattern)
    $cfiles.delete_if { |f| p =~ f.file }
  end

  opts.on("--delete-if CONDITION", "delete files satisfying CONDITION.") do |condition| 
    $cfiles.delete_if do |f|
      if f.blockdev?
        false
      else
        eval condition 
      end
    end
  end

  opts.on("--defrag HABITAT", "do poor man's defrag via dir HABITAT.") do |habitat| 

		if not 'Ss016'.include? `runlevel`[2]
			puts 'WARNING: defraging in multi-user mode may lead to data corruption. Continue anyway? [y/N]'
			if readline[0] != ?y then return end
		end

		mtab = FSTab.new '/etc/mtab'
    $cfiles.each do |f|
			# skip obscure files
			fstat = File.lstat f.file
      next if fstat.file?

			# skip opened files
			File.open(f.file) do |f|
				if not f.flock(File::LOCK_EX | File::LOCK_NB)
					puts "skiping opened file #{f.file}" if $verbose >= 2
					next
				end
				f.flock(File::LOCK_UN)
			end

			# poor man's defrag ;-)
			tmpfile = mtab[f.dev].mount_point + '/' + habitat + '/' + File.basename(f.file)
			begin
				FileUtils.cp f.file, tmpfile, :preserve => true
				tstat = File.lstat tmpfile
				raise "not in same filesystem" if fstat.dev != tstat.dev
				raise "file changed" if fstat.size != tstat.size or
																fstat.mode != tstat.mode or
																fstat.mtime != tstat.mtime
				FileUtils.rm f.file
				FileUtils.ln tmpfile, f.file
				FileUtils.rm tmpfile
			rescue Exception => msg
				$stderr.puts "Failed to defrag file #{f.file} => #{tmpfile}: #{msg}."
				exit 1
			end
    end
  end

  opts.on_tail("-h", "--help", "Show this message.") do
    puts opts
  end
end

begin
  opts.parse(ARGV)
# rescue NoMethodError => err 
#   puts "May not specify the option '--restore/--snapshot'."
#   puts
  # puts opts
rescue => err
  puts err.backtrace
  $stderr.puts "#{err}\n"
end

# vim: sw=2 ts=2
