#!/bin/sh

VERBOSE=0
CACHE_ROOT=/var/cache/bootcache
. /etc/default/bootcache

FILECACHE=filecache

task=${2:-boot}
task_root="$CACHE_ROOT/$task"
preload_root="$task_root/preload"
defrag_root="$task_root/defrag"

[ ! -d "$task_root" ] && mkdir -p "$task_root"

function print_help()
{
    echo "Usage: $0 start/stop/preload/defrag/defrag-now <task>"
}

function rotate_snapshots()
{
    [ -e "$1/snapshot2" ] && rm -fr "$1/snapshot2"
    [ -e "$1/snapshot1" ] && mv "$1/snapshot1" "$1/snapshot2"
    [ -e "$1/snapshot0" ] && mv "$1/snapshot0" "$1/snapshot1"
    mkdir -p "$1/snapshot0"
}

function start()
{
    rotate_snapshots "$task_root"

    $FILECACHE --snapshot --dump "$task_root/snapshot0/start"
}

function stop()
{
    # the boot task will have empty content for start
    [ ! -d "$task_root/snapshot0/start" ] && mkdir "$task_root/snapshot0/start"

    $FILECACHE --snapshot --dump "$task_root/snapshot0/stop"
    $FILECACHE --load "$task_root/snapshot0/stop" \
                    --difference "$task_root/snapshot0/start" \
                    --dump "$preload_root"
}


function setup_queue
{
    QUEUES=`echo /sys/block/*/queue`
    for QUEUE in $QUEUES
    do
        echo deadline   >   $QUEUE/scheduler
        echo 10240      >   $QUEUE/nr_requests
        echo 4096       >   $QUEUE/max_sectors_kb
        echo 10         >   $QUEUE/iosched/fifo_batch
        echo 0          >   $QUEUE/iosched/read_expire
        echo 120000     >   $QUEUE/iosched/reada_expire
        echo 120000     >   $QUEUE/iosched/write_expire
        echo 1000       >   $QUEUE/iosched/writes_starved
        echo 10         >   /proc/sys/vm/vfs_cache_pressure
    done
}

function reset_queue
{
    QUEUES=`echo /sys/block/*/queue`
    for QUEUE in $QUEUES
    do
        echo 128        >   $QUEUE/nr_requests
        echo 100        >   $QUEUE/iosched/read_expire
        echo 3000       >   $QUEUE/iosched/write_expire
        echo 500        >   $QUEUE/iosched/writes_starved
    done

}

function preload
{
    [ ! -d "$preload_root" ] && echo "$preload_root/ does not exist!" && return

    [ -x /usr/bin/renice ] && /usr/bin/renice 19 $$ > /dev/null

    devs=`cd "$preload_root"; echo *`
    devs=${devs/bdev}

    readahead-fs "$preload_root/bdev"

    for dev in $devs
    do
        file="$preload_root/$dev"
        [ -f "$file" ] || continue

        (
            while true
            do
                grep -q $dev /etc/mtab    && break
                grep -q $dev /proc/mounts && break
                sleep 1
            done

            readahead-fs "$file"
        )&
    done
}

function schedule_defrag()
{
    $FILECACHE --load "$preload_root" \
                    --delete-if 'f.size > 200' \
                    --prune-path '^/bin/' \
                    --prune-path '^/lib/lib' \
                    --prune-path '^/lib/lsb/lib' \
                    --dump "$defrag_root"
}

function do_defrag()
{
    # prepare the defrag habitat dirs for each filesystem
    defrag_habitat=".defrag-habitat-$task"
    while read devfile mp fstype options
    do
        dfrag_dir="$mp/$defrag_habitat"

        if [ -d $dfrag_dir ]; then continue; fi
        if [ ! -b $devfile ]; then continue; fi

        if [ $fstype = "ext2" -o $fstype = "ext3" ]; then
            mount -o oldalloc,remount $mp
        fi

        mkdir $dfrag_dir

        if [ $fstype = "ext2" -o $fstype = "ext3" ]; then
            mount -o orlov,remount $mp
        fi
    done < /etc/mtab

    # ok, someone insists on doing the defrag...
    if [ ! -d $defrag_root ]; then
        [ $VERBOSE -gt 0 ] && echo "Preparing defrag task $task for immediate run..."
        schedule_defrag || return
    fi

    # do poor man's defrag
    $FILECACHE --load "$defrag_root" \
                --defrag "$defrag_habitat"

    # cleanup the defrag root, or bootcache.sh will call us again and again!
    if [ $? -eq 0 ]; then
        rm -fr "$defrag_root"
    else
        rm -fr "$defrag_root.err"
        mv "$defrag_root" "$defrag_root.err"
        return
    fi

    # update the moved fs metadata
    # it will include old metadata from the deleted inodes
    # so running an update on the next boot is recommended
    $FILECACHE --snapshot --delete-if "not f.blockdev?" \
                --union "$preload_root/bdev" \
                --dump "$preload_root"
}

function wait_for_process_stop()
{
    while pidof $1 > /dev/null; do sleep 1; done
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    preload)
        trap "reset_queue; exit" EXIT HUP INT ABRT QUIT SEGV TERM
        setup_queue
        preload
        wait_for_process_stop readahead-fs
        reset_queue
        ;;
    defrag)
        schedule_defrag
        if [ $VERBOSE -gt 0 ]; then
            echo "Defrag task $task scheduled, will run it on reboot/shutdown."
            echo "It is recommended to take a new snapshot on next boot,"
            echo "for the defrag will make our metadata info out of sync."
        fi
        ;;
    defrag-now)
        do_defrag
        ;;
    *)
        print_help
        ;;
esac

# vim: ts=4 sw=4 et
