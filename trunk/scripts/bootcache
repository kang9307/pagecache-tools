#!/bin/sh

VERBOSE=0
CACHE_ROOT=/var/cache/bootcache
. /etc/default/bootcache

FILECACHE="filecache --verbose $VERBOSE"

task=${2:-boot}
task_root="$CACHE_ROOT/$task"
preload_root="$task_root/preload"
defrag_root="$task_root/defrag"

[ ! -d "$task_root" ] && mkdir -p "$task_root"

function print_help()
{
    echo "Usage: $0 start|stop|preload|defrag|defrag-now [task]"
}

function rotate_snapshots()
{
    [ -e "$1/snapshot2" ] && rm -fr "$1/snapshot2"
    [ -e "$1/snapshot1" ] && mv "$1/snapshot1" "$1/snapshot2"
    [ -e "$1/snapshot0" ] && mv "$1/snapshot0" "$1/snapshot1"
    mkdir -p "$1/snapshot0"
}

function start()
{
    rotate_snapshots "$task_root"

    $FILECACHE --snapshot --dump "$task_root/snapshot0/start"
}

function stop()
{
    # the boot task will not be calling start
    if [ -d "$task_root/snapshot0/stop" ]; then
        rotate_snapshots "$task_root"
    fi

    # ditto
    if [ ! -d "$task_root/snapshot0/start" ]; then
        mkdir -p "$task_root/snapshot0/start"
    fi

    $FILECACHE --snapshot --dump "$task_root/snapshot0/stop"
    $FILECACHE --load "$task_root/snapshot0/stop" \
                    --difference "$task_root/snapshot0/start" \
                    --dump "$preload_root"
}


function setup_queue
{
    QUEUES=`echo /sys/block/*/queue`
    ELEVATORS=
    local deadline=no
    for queue in $QUEUES
    do
        local elevators=$(<$queue/scheduler)
        for elv in $elevators
        do
            case "$elv" in
                '[noop]')
                        oelv=noop
                        ;;
                '[cfq]')
                        oelv=cfq
                        ;;
                'deadline')
                        deadline=yes
                        ;;
                '[deadline]')
                        deadline=yes
                        oelv=deadline
                        ;;
                '[anticipatory]')
                        oelv=anticipatory
                        ;;
            esac
        done
        [ $deadline = 'yes' ] || modprobe deadline-iosched || return

        ELEVATORS="$ELEVATORS $oelv"
        echo deadline   >   $queue/scheduler
        echo 10240      >   $queue/nr_requests
        echo 4096       >   $queue/max_sectors_kb
        echo 10         >   $queue/iosched/fifo_batch
        echo 0          >   $queue/iosched/read_expire
        echo 120000     >   $queue/iosched/reada_expire
        echo 120000     >   $queue/iosched/write_expire
        echo 1000       >   $queue/iosched/writes_starved
        echo 10         >   /proc/sys/vm/vfs_cache_pressure
    done
}

function reset_queue
{
    for queue in $QUEUES
    do
        elv=$1
        shift
        if [ -z "$elv" ]; then
            return
        elif [ $elv != 'deadline' ]; then
            echo $elv > $queue/scheduler
        else
            echo 100  > $queue/iosched/read_expire
            echo 3000 > $queue/iosched/write_expire
            echo 500  > $queue/iosched/writes_starved
        fi
        echo 128  > $queue/nr_requests
    done
}

function preload
{
    [ -d "$preload_root" ] || { echo "no preload data for task '$task'"; return 1; }

    [ -x /usr/bin/renice ] && /usr/bin/renice 19 $$ > /dev/null

    devs=`cd "$preload_root"; echo *`
    devs=${devs/bdev}

    readahead-fs "$preload_root/bdev"

    for dev in $devs
    do
        file="$preload_root/$dev"
        [ -f "$file" ] || continue

        (
            while true
            do
                grep -q $dev /etc/mtab    && break
                grep -q $dev /proc/mounts && break
                sleep 1
            done

            readahead-fs "$file"
        )&
    done
}

function schedule_defrag()
{
    $FILECACHE --load "$preload_root" \
                    --delete-if 'f.size > 200' \
                    --prune-path '^/bin/' \
                    --prune-path '^/lib/lib' \
                    --prune-path '^/lib/lsb/lib' \
                    --dump "$defrag_root"
}

function do_defrag()
{
    # prepare the defrag habitat dirs for each filesystem
    defrag_habitat=".defrag-habitat-$task"
    while read dev mp fstype options
    do
        defrag_dir="$mp/$defrag_habitat"

        if [ -d "$defrag_dir" ]; then continue; fi
        if [ ! -b "$dev" ];      then continue; fi

        if [ $fstype = 'ext2' -o $fstype = 'ext3' ]; then
            mount -o oldalloc,remount $mp
        fi

        mkdir "$defrag_dir"

        if [ $fstype = 'ext2' -o $fstype = 'ext3' ]; then
            mount -o orlov,remount $mp
        fi
    done < /etc/mtab

    # ok, someone insists on doing the defrag...
    if [ ! -d "$defrag_root" ]; then
        [ $VERBOSE -gt 0 ] && echo "Preparing defrag task $task for immediate run..."
        schedule_defrag || return
    fi

    # do poor man's defrag
    $FILECACHE --load "$defrag_root" \
                --defrag "$defrag_habitat"

    # cleanup the defrag root, or bootcache.sh will call us again and again!
    if [ $? -eq 0 ]; then
        rm -fr "$defrag_root"
    else
        rm -fr "$defrag_root.err"
        mv "$defrag_root" "$defrag_root.err"
        return 1
    fi

    # update the moved fs metadata
    # it will include old metadata from the deleted inodes
    # so running an update on the next boot is recommended
    $FILECACHE --snapshot --delete-if "not f.blockdev?" \
                --union "$preload_root/bdev" \
                --dump "$preload_root"
}

function wait_for_process_stop()
{
    while pidof $1 > /dev/null; do sleep 1; done
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    preload)
        trap "reset_queue; exit" EXIT HUP INT ABRT QUIT SEGV TERM
        setup_queue
        preload
        wait_for_process_stop readahead-fs
        reset_queue $ELEVATORS
        ;;
    defrag)
        schedule_defrag
        if [ $VERBOSE -gt 0 ]; then
            echo "Defrag task $task scheduled, will run it on reboot/shutdown."
            echo "It is recommended to take a new snapshot on next boot,"
            echo "for the defrag will make our metadata info out of sync."
        fi
        ;;
    defrag-now)
        do_defrag
        ;;
    *)
        print_help
        ;;
esac

# vim: ts=4 sw=4 et
