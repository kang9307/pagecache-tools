#!/bin/sh

VERBOSE=0
CACHE_ROOT=/var/cache/bootcache
. /etc/default/bootcache

FILECACHE="filecache --verbose $VERBOSE"

TASK=${2:-boot}
TASK_ROOT="$CACHE_ROOT/$TASK"
PRELOAD_ROOT="$TASK_ROOT/preload"
DEFRAG_ROOT="$TASK_ROOT/defrag"
DEFRAG_HABITAT=".defrag-habitat-$TASK"

function print_help()
{
    echo "Usage: $0 start|stop|preload|defrag|defrag-now|clear [task]"
}

function rotate_snapshots()
{
    [ -e "$1/snapshot2" ] && rm -fr "$1/snapshot2"
    [ -e "$1/snapshot1" ] && mv "$1/snapshot1" "$1/snapshot2"
    [ -e "$1/snapshot0" ] && mv "$1/snapshot0" "$1/snapshot1"
    mkdir -p "$1/snapshot0"
}

function do_start()
{
    rotate_snapshots "$TASK_ROOT"

    $FILECACHE --snapshot --dump "$TASK_ROOT/snapshot0/start"
}

function do_stop()
{
    # the boot task will not be calling start
    if [ -d "$TASK_ROOT/snapshot0/stop" ]; then
        rotate_snapshots "$TASK_ROOT"
    fi

    # ditto
    if [ ! -d "$TASK_ROOT/snapshot0/start" ]; then
        mkdir -p "$TASK_ROOT/snapshot0/start"
    fi

    $FILECACHE --snapshot "state.include?(?R) or \
                           state.include?(?A) or \
                           state.include?(?M)" \
                    --dump "$TASK_ROOT/snapshot0/stop" \
                    --difference "$TASK_ROOT/snapshot0/start" \
                    --prune-path '^(/var/|/tmp/)' \
                    --dump "$PRELOAD_ROOT"
}


function setup_queue
{
    QUEUES=`echo /sys/block/*/queue`
    ELEVATORS=
    local deadline=no
    for queue in $QUEUES
    do
        local elevators=$(<$queue/scheduler)
        for elv in $elevators
        do
            case "$elv" in
                '[noop]')
                        oelv=noop
                        ;;
                '[cfq]')
                        oelv=cfq
                        ;;
                'deadline')
                        deadline=yes
                        ;;
                '[deadline]')
                        deadline=yes
                        oelv=deadline
                        ;;
                '[anticipatory]')
                        oelv=anticipatory
                        ;;
            esac
        done
        
        [ $deadline = 'yes' ] || modprobe deadline-iosched ||
            { echo "deadline elevator is required for preloading"; exit 1; }

        ELEVATORS="$ELEVATORS $oelv"
        echo deadline   >   $queue/scheduler
        echo 10240      >   $queue/nr_requests
        echo 4096       >   $queue/max_sectors_kb
        echo 10         >   $queue/iosched/fifo_batch
        echo 0          >   $queue/iosched/read_expire
        echo 120000     >   $queue/iosched/reada_expire
        echo 120000     >   $queue/iosched/write_expire
        echo 1000       >   $queue/iosched/writes_starved
        echo 0          >   /proc/sys/vm/vfs_cache_pressure
    done
}

function reset_queue
{
    for queue in $QUEUES
    do
        elv=$1
        shift
        if [ -z "$elv" ]; then
            return
        elif [ $elv != 'deadline' ]; then
            echo $elv > $queue/scheduler
        else
            echo 100  > $queue/iosched/read_expire
            echo 3000 > $queue/iosched/write_expire
            echo 500  > $queue/iosched/writes_starved
        fi
        echo 128  > $queue/nr_requests
        echo 50   > /proc/sys/vm/vfs_cache_pressure
    done
}

function do_preload
{
    [ -d "$PRELOAD_ROOT" ] || { echo "no preload data for task '$TASK'"; Return 1; }

    [ -x /usr/bin/renice ] && /usr/bin/renice 19 $$ > /dev/null
    [ -x /usr/bin/ionice ] && /usr/bin/ionice -c3 -p$$

    readahead-fs -t 1 "$PRELOAD_ROOT/bdev" &

    until pidof udevd > /dev/null; do sleep 1; done

    local devs=`cd "$PRELOAD_ROOT"; echo *`

    for dev in ${devs/bdev}
    do
        file="$PRELOAD_ROOT/$dev"
        [ -f "$file" ] || continue

        (
            while true
            do
                grep -q $dev /etc/mtab    && break
                grep -q $dev /proc/mounts && break
                sleep 1
            done

            readahead-fs -t 50 "$file"
        )&
    done
}

function schedule_defrag()
{
    $FILECACHE --load "$PRELOAD_ROOT" \
                    --delete-if 'f.size > 200' \
                    --dump "$DEFRAG_ROOT"
}

function defrag_habitat_dir()
{
    while read dev mp fstype options
    do
        local defrag_dir="$mp/$DEFRAG_HABITAT"

        [ -b "$dev" ] || continue

        # clear task dirs?
        if [ $1 = 'rmdir' ]; then
            [ -d "$defrag_dir" ] && rmdir "$defrag_dir"
            continue
        fi

        # defrag habitat dirs should be
        # consistent/persistent - created once, reuse afterwards
        [ -d "$defrag_dir" ] && continue

        if [ $fstype = 'ext2' -o $fstype = 'ext3' ]; then
            mount -o oldalloc,remount $mp
        fi

        mkdir "$defrag_dir"

        if [ $fstype = 'ext2' -o $fstype = 'ext3' ]; then
            mount -o orlov,remount $mp
        fi
    done < /etc/mtab
}

function do_defrag()
{
    # prepare the defrag habitat dirs for each filesystem
    defrag_habitat_dir mkdir

    # ok, someone insists on doing the defrag...
    if [ ! -d "$DEFRAG_ROOT" ]; then
        [ $VERBOSE -gt 0 ] && echo "Preparing defrag task $task for immediate run..."
        schedule_defrag || return
    fi

    # do poor man's defrag
    echo -n "running poor man's defrag for task '$TASK' ..."
    $FILECACHE --load "$DEFRAG_ROOT" \
                --defrag "$DEFRAG_HABITAT"

    # cleanup the defrag root, or bootcache.sh will call us again and again!
    local retval=$?
    rm -fr "$DEFRAG_ROOT.old"
    mv "$DEFRAG_ROOT" "$DEFRAG_ROOT.old"
    [ $retval -eq 0 ] || { echo 'failed'; return 1; }

    # update the moved fs metadata
    # it will include old metadata from the deleted inodes
    # so running an update on the next boot is recommended
    $FILECACHE --snapshot 'state.include?(?D)' \
                --delete-if 'not f.blockdev?' \
                --union "$PRELOAD_ROOT/bdev" \
                --dump "$PRELOAD_ROOT"

    echo 'done'
}

function do_clear()
{
    rm -fr "$TASK_ROOT"
    defrag_habitat_dir rmdir
}

function wait_for_process_stop()
{
    while pidof $1 > /dev/null; do sleep 1; done
}

case "$1" in
    start)
        do_start
        ;;
    stop)
        do_stop
        ;;
    preload)
        trap "reset_queue; exit" EXIT HUP INT ABRT QUIT SEGV TERM
        setup_queue
        do_preload
        wait_for_process_stop readahead-fs
        reset_queue $ELEVATORS
        ;;
    defrag)
        schedule_defrag
        if [ $VERBOSE -gt 0 ]; then
            echo "Defrag task $task scheduled, will run it on reboot/shutdown."
            echo "It is recommended to take a new snapshot on next boot,"
            echo "for the defrag will make our metadata info out of sync."
        fi
        ;;
    defrag-now)
        do_defrag
        ;;
    clear)
        do_clear
        ;;
    *)
        print_help
        ;;
esac

# vim: ts=4 sw=4 et
