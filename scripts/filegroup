#!/bin/sh

CACHE_ROOT=/var/cache/filegroup
# .  etc/default/filegroup

FILECACHE=filecache
RAFS=readahead-fs.sh
PATH=.:$PATH

task=$2
task_root="${CACHE_ROOT}/$task"

function print_help()
{
    echo "Usage: $0 start/stop/preload/defrag/defrag-now <task>"
}

function rotate()
{
    [ -e ${task_root}/snapshot2 ] && rm -fr ${task_root}/snapshot2
    [ -e ${task_root}/snapshot1 ] && mv ${task_root}/snapshot1 ${task_root}/snapshot2
    [ -e ${task_root}/snapshot0 ] && mv ${task_root}/snapshot0 ${task_root}/snapshot1
}

function start()
{
    rotate ${task_root} 

    ${FILECACHE} --snapshot --dump "${task_root}/snapshot0/start"
}

function stop()
{
    ${FILECACHE} --snapshot --dump "${task_root}/snapshot0/stop"
    ${FILECACHE} --restore "${task_root}/snapshot0/stop" \
					--difference "${task_root}/snapshot0/start" \
					--dump "${task_root}/preload" 
}


# function save_queue
# {
#     QUEUES=`echo /sys/block/*/queue`
#     for QUEUE in ${QUEUE}
#     do
#         SCHEDULER=`cat ${QUEUE}/scheduler | sed -e "s/^.*\[\(.*\)\].*$/\1/g"`
#         NR_REQUESTS=`cat $QUEUE/nr_requests`
#         MAX_SECTORS_KB=`cat $QUEUE/max_sectors_kb`
#         FIFO_BATCH=`cat $QUEUE/iosched/fifo_batch`
#         READ_EXPIRE=`cat $QUEUE/iosched/read_expire`
#         READA_EXPIRE=`cat $QUEUE/iosched/reada_expire`
#         WRITE_EXPIRE=`cat $QUEUE/iosched/write_expire`
#         WRITES_STARVED=`cat $QUEUE/iosched/writes_starved`
#         VFS_CACHE_PRESSURE=`cat /proc/sys/vm/vfs_cache_pressure`
#     done
# }

function setup_queue
{
    QUEUES=`echo /sys/block/*/queue`
    for QUEUE in ${QUEUES}
    do
        echo deadline   >   $QUEUE/scheduler
        echo 10240      >   $QUEUE/nr_requests
        echo 4096       >   $QUEUE/max_sectors_kb
        echo 10         >   $QUEUE/iosched/fifo_batch
        echo 0          >   $QUEUE/iosched/read_expire
        echo 120000     >   $QUEUE/iosched/reada_expire
        echo 120000     >   $QUEUE/iosched/write_expire
        echo 1000       >   $QUEUE/iosched/writes_starved
        echo 10         >   /proc/sys/vm/vfs_cache_pressure
    done
}

function reset_queue
{
    QUEUES=`echo /sys/block/*/queue`
    for QUEUE in ${QUEUES}
    do
        # [ -n "${SCHEDULER}" ] && echo ${SCHEDULER} > $QUEUE/scheduler
        # ${NR_REQUESTS}
        # ${MAX_SECTORS_KB}
        # ${FIFO_BATCH}
        # ${READ_EXPIRE}
        # ${READA_EXPIRE}
        # ${WRITE_EXPIRE}
        # ${WRITES_STARVED}
        # ${VFS_CACHE_PRESSURE}

        echo 128        >   $QUEUE/nr_requests
        echo 100        >   $QUEUE/iosched/read_expire
        echo 3000       >   $QUEUE/iosched/write_expire
        echo 500        >   $QUEUE/iosched/writes_starved
    done

}

function preload
{
    [ ! -d "${task_root}/preload" ] && return

    files=`echo ${task_root}/preload/*`

    ## ionice ??
    
    for file in ${files}
    do
        [ ! -f file ] && continue

        ${RAFS} file &
    done
}

function defrag()
{
    ${FILECACHE} --restore "${task_root}/preload" --delete "cf.size > 500" \
					--dump-file-list "${task_root}/defrag" 
	echo ${task} >> ${CACHE_ROOT}/defrag
}

function defrag_now()
{

    runlevel=`runlevel | cut -d' ' -f2`

    if [[ ! ${runlevel} =~ "[Ss016]" ]]; then
        read -p "Warning: defraging in muti-user mode is dangerous. Continue?[y/N]" cont  
        if [[ ! ${cont} =~ "^[yY]" ]]; then
            return
        fi
    fi

    files=`echo ${task_root}/defrag/*`

    for file in ${files}
    do
        [ ! -f file ] && continue

        device=`basename file`
        fstab=`grep ${device} /etc/fstab | sed -e "s/\t/ /g" | sed -e "s/  */ /g"` 
        mp=`cat ${fstab} | cut -d' ' -f2`
        fstype=`cat ${fstab} | cut -d' ' -f3`

        dir="${mp}/.poor_mans_defrag-${task}"

        if [ ! -d ${dir} ]; then
            if [ "${fstype}" == "ext2" || "${fstype}" == "ext3" ]; then
                mount -o oldalloc,remount ${mp}
            fi
            mkdir -p ${dir}
            if [ "${fstype}" == "ext2" || "${fstype}" == "ext3" ]; then
                mount -o orlov,remount ${mp}
            fi
        fi

        (
        while true
        do
            read thefile
            [ -z ${thefile} ] && break
            dstfile=`basename ${thefile}`
            cp ${thefile} ${dir}
            mv ${dir}/${dstfile} ${thefile}
        done < file
        )

    done
}

[ $# -lt 2 ] && print_help && exit

[ ! -e ${task_root} ] && mkdir -p ${task_root}
[ ! -d ${task_root} ] && rm -fr ${task_root} && mkdir -p ${task_root}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    preload)
        # save_queue
        trap "reset_queue; exit" EXIT HUP INT ABRT QUIT SEGV TERM
        setup_queue
        preload
        reset_queue
        ;;
    defrag)
        defrag
        ;;
    defrag-now)
        defrag_now
        ;;
    *)
        print_help
        ;;
esac

# vim: ts=4 sw=4
